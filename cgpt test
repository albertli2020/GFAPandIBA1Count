import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import tifffile as tif
import numpy as np
import os 
import cv2
from scipy import ndimage as ndi
from skimage.segmentation import watershed
from skimage.feature import peak_local_max
from skimage.measure import regionprops
from skimage.morphology import remove_small_objects, binary_closing, disk
from skimage.filters import gaussian



url = "/Users/albert2/Downloads/d1_reimage/fov_3_MMStack_4-Pos016_013.ome.tif"
tif_stack = tif.imread(url)
# Show image, not needed tehe
# image = np.stack((tif_stack[2], tif_stack[1], tif_stack[0]), axis = -1)
# image = ((image - 181) / 4666.0 * 255).astype(np.uint8)
# plt.imshow(image)
# plt.show()

# 16 13 is 263
# 16 12 is 256

blueChannel = tif_stack[256][0]
greenChannel = tif_stack[256][1]
redChannel = tif_stack[256][2]
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))
ax1.imshow(blueChannel, cmap="Blues_r")
ax1.set_title("Blue Channel")
ax2.imshow(greenChannel, cmap="Greens_r")
ax2.set_title("Green Channel")
ax3.imshow(redChannel, cmap="Reds_r")
ax3.set_title("Red Channel")
plt.show()

def preprocess_image(channel):
    # Apply Gaussian blur
    blurred = cv2.GaussianBlur(channel, (11, 11), 0)
    # Apply Otsu's thresholding
    _, thresh = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    # Convert to boolean
    binary = thresh > 0
    # Apply morphological closing
    binary = binary_closing(binary, disk(3))
    # Remove small objects and fill holes
    binary = remove_small_objects(binary, min_size=50)
    binary = ndi.binary_fill_holes(binary)
    return binary.astype(np.uint8)

def segment_cells(channel):
    # Preprocess the image
    binary = preprocess_image(channel)
    
    # Compute the distance transform
    distance = ndi.distance_transform_edt(binary)
    
    # Find local maxima
    local_maxi = peak_local_max(distance, footprint=np.ones((3, 3)), 
                                labels=binary, min_distance=20)
    
    # Create markers for watershed
    markers = np.zeros(binary.shape, dtype=bool)
    markers[tuple(local_maxi.T)] = True
    markers, _ = ndi.label(markers)
    
    # Apply watershed
    labels = watershed(-distance, markers, mask=binary)
    
    # Remove small objects from the labels
    labels = remove_small_objects(labels, min_size=100)
    
    # Relabel the remaining objects
    labels, _ = ndi.label(labels > 0)
    
    return labels

# Apply the segmentation to the blue channel
labels = segment_cells(blueChannel)

# Display watershed result
plt.imshow(labels, cmap='Blues_r')
plt.show()

# Count cells and create masks for other channels
blue_mask = np.zeros_like(blueChannel)
green_mask = np.zeros_like(greenChannel)
red_mask = np.zeros_like(redChannel)

cell_count = np.max(labels)
for label in range(1, cell_count + 1):
    blue_mask[labels == label] = 255
    green_mask[labels == label] = greenChannel[labels == label]
    red_mask[labels == label] = redChannel[labels == label]

# Create a labeled mask
labeled_mask = np.zeros_like(blueChannel, dtype=np.uint8)
for label in range(1, cell_count + 1):
    labeled_mask[labels == label] = label

# Display labeled mask
fig, ax = plt.subplots(figsize=(10, 10))
ax.imshow(labeled_mask, cmap='nipy_spectral')

# Add labels to each cell
for region in regionprops(labeled_mask):
    # Skip small regions
    if region.area < 50:
        continue
    # Draw label at the centroid of each region
    y, x = region.centroid
    ax.text(x, y, str(region.label), fontsize=8, color='white', 
            ha='center', va='center')

ax.set_title(f"Labeled Mask (Total cells: {cell_count})")
plt.show()

# Function to display masks with labels
def display_labeled_mask(mask, title, cmap):
    fig, ax = plt.subplots(figsize=(10, 10))
    ax.imshow(mask, cmap=cmap)
    
    for region in regionprops(labeled_mask):
        if region.area < 50:
            continue
        y, x = region.centroid
        ax.text(x, y, str(region.label), fontsize=8, color='white', 
                ha='center', va='center')
    
    ax.set_title(title)
    plt.show()

print(f"Total number of cells: {cell_count}")
